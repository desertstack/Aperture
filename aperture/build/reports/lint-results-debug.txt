/Users/rajivsingh/development/myApps/android/Aperture/aperture/src/main/kotlin/io/aperture/Aperture.kt:16: Warning: Do not place Android context classes in static fields (static reference to Aperture which has field context pointing to Context); this is a memory leak [StaticFieldLeak]
/**
^
/Users/rajivsingh/development/myApps/android/Aperture/aperture/src/main/kotlin/io/aperture/Aperture.kt:22: Warning: Do not place Android context classes in static fields; this is a memory leak [StaticFieldLeak]
    private var context: Context? = null
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Explanation for issues of type "StaticFieldLeak":
   A static field will leak contexts.

   Non-static inner classes have an implicit reference to their outer class.
   If that outer class is for example a Fragment or Activity, then this
   reference means that the long-running handler/loader/task will hold a
   reference to the activity which prevents it from getting garbage
   collected.

   Similarly, direct field references to activities and fragments from these
   longer running instances can cause leaks.

   ViewModel classes should never point to Views or non-application Contexts.

/Users/rajivsingh/development/myApps/android/Aperture/aperture/src/main/kotlin/io/aperture/service/ApertureService.kt:139: Warning: Use the KTX extension function String.toUri instead? [UseKtx]
        val openBrowserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(serverUrl)).apply {
                                                           ~~~~~~~~~~~~~~~~~~~~

   Explanation for issues of type "UseKtx":
   The Android KTX libraries decorates the Android platform SDK as well as
   various libraries with more convenient extension functions available from
   Kotlin, allowing you to use default parameters, named parameters, and
   more.

   Available options:

   **remove-defaults** (default is true):
   Whether to skip arguments that match the defaults provided by the extension.

   Extensions often provide default values for some of the parameters. For example:
   ```kotlin
   fun Path.readLines(charset: Charset = Charsets.UTF_8): List<String> { return Files.readAllLines(this, charset) }
   ```
   This lint check will by default automatically omit parameters that match the default, so if your code was calling

   ```kotlin
   Files.readAllLines(file, Charset.UTF_8)
   ```
   lint would replace this with
   ```kotlin
   file.readLines()
   ```
   rather than

   ```kotlin
   file.readLines(Charset.UTF_8
   ```
   You can turn this behavior off using this option.

   To configure this option, use a `lint.xml` file with an <option> like this:

   ```xml
   <lint>
       <issue id="UseKtx">
           <option name="remove-defaults" value="true" />
       </issue>
   </lint>
   ```

   **require-present** (default is true):
   Whether to only offer extensions already available.

   This option lets you only have lint suggest extension replacements if those extensions are already available on the class path (in other words, you're already depending on the library containing the extension method.)

   To configure this option, use a `lint.xml` file with an <option> like this:

   ```xml
   <lint>
       <issue id="UseKtx">
           <option name="require-present" value="true" />
       </issue>
   </lint>
   ```

0 errors, 3 warnings
